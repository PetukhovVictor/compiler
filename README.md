## Актуальность

**На данный момент README неактуален, помимо описанного:**
1. Реализован компилятор в код стековой машины;
2. Реализована сама стеквоая машина;
3. Реализован компилятор в ASM-код (NASM) под X86.

Через некоторое время README будет обновлен.

# Учебный компилятор

## Features

1. **Арифметически выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
    1. `*`, `/`, `%`
    2. `+`, `-`
2. **Логические выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
и операторы сравнения и проверки равенства
    1. `==`, `!=`, `>`, `>=`, `<`, `<=`
    2. `&&`
    3. `||`, `!!`
3. **Переменые** 
    1. `x := 5 * y`
    2. `z := x <= y`
4. **Операции ввода-вывода** (ввод и вывод осуществляется в стандартные потоки ввода и вывода: stdin, stdout)
    1. `x := read()`
    2. `write(x)`
5. **Условия** с альтернативным ветками (как конкретными, так и обобщенными)
    ```
    if x >= y && z then
        write(x)
    elif !z then
        write(y)
    else
        write(z) fi   
    ```
6. **Циклы while**
    ```
    while k > 0
    do
        res := res * n;
        k := k - 1
    od;
    ```
7. **Циклы for** с поддержкой составных условий и skip в предусловии
    ```
    for c := 2, c * c <= p && f, c := c + 1
    do
        f := p % c != 0
    od;
    ```
    ```
    for skip, n >= 1, n := n-1
    do
        f := f * n
    od;
    ```
8. **Фукнции**
    ```
    fun A (m, n)
    begin
        if m == 0 then return n+1
        elif m > 0 && n == 0 then return A (m-1, 1)
        else return A (m-1, A(m, n-1))
        fi
    end
    
    write (A (1, 21))
    ```
    
9. **Символы**
    1. `C := 'a'`

10. **Строки** и набор предопределенных функций для работы с ними:<br />
    `S := "I will remember April."`
    1. **strlen** - получение длины строки:<br />
        `strlen(S)` => `22`
    2. **strget** - получение заданного символа строки:<br />
        `strget(S, 2)` => `w`
    3. **strsub** - получение подстроки, начиная с символа n, длиной в k символов:<br />
        `strsub (S, 7, 8)` => `remember`
    4. **strdup** - копирование строки:<br />
        `strdup(S)` => `I will remember April.`,
    5. **strset** - задание i-го символа строки:<br />
        `strset(S, 4, 'j')` => `I wijl remember April.`,
    6. **strcat** - конкатенация двух строк:<br />
        `strcat(S, " It was very cold.")` => `I will remember April. It was very cold.`,
    7. **strcmp** - сравнение двух строк (сравнение осуществляется по кодам символов строк, слева направо):<br />
        `strcmp(S, "I wijl remember April.")` => `1`<br />
        `strcmp(S, "I wiz")` => `-1`<br />
        `strcmp(S, "I will")` => `-1`<br />
        `strcmp(S, "I will remember April.")` => `0`
    8. **strmake** - создание строки из n повторящихся символов:<br />
        `strmake (10, 'a')` => `aaaaaaaaaa`

11. **Массивы значений** (unboxed-массивы) и набор предопределенных функций для работы с ними:<br />
    1. **arrmake** - создание массива:<br />
        1. `S := arrmake (5)` => `[0, 0, 0, 0, 0]`
        2. `S := arrmake (5, 0)` => `[0, 0, 0, 0, 0]`
        3. `S := arrmake (5, [])` => `[0, 0, 0, 0, 0]`
        4. `S := arrmake (5, [1, 2, 3, 4, 5])` => `[1, 2, 3, 4, 5]`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    4. Присвоение значения элементу массива по индексу:<br />
        `S[1] := 4` => `[0, 4, 0, 0, 0]`
    5. Получение значения элемента массива по индексу:<br /> 
        `write(S[1])` => `4`

11. **Массивы ссылок** (boxed-массивы) и набор предопределенных функций для работы с ними:<br />
    1. **Arrmake** - создание массива:<br />
        1. `S := Arrmake (5)` => `[nullptr, nullptr, nullptr, nullptr, nullptr]`
        2. `S := Arrmake (5, {})` => `[nullptr, nullptr, nullptr, nullptr, nullptr]`
        3. Присвоение со значением по умолчанию:<br />
            1. `S1 := arrmake (2, 1)` => `[1, 1]`
            2. `S2 := arrmake (2, 3)` => `[3, 3]`
            3. `S := Arrmake (2, {S1, S2})` => `[S1, S2]`
            4. `S2[1] := 4`
            5. `write(S[0][1])` => `1`
            6. `write(S[1][0])` => `3`
            7. `write(S[1][1])` => `4`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    4. Присвоение ссылки элементу массива по индексу:<br />
        `S[1] := S1` => `[1, 1]`
    5. Получение значения элемента массива по индексу:<br /> 
        `write(S[1][0])` => `1`
        
## Реализация лексера

Лексер токенизирует код по набору регэкспов. Регэкспы задаются в файле `Lexer/tokenizer.py`.
Там перечислены все ключевые слова языка и шаблоны литералов, а также идентификаторов.

Помимо регэкспа можно задать левый и правый контексты, чтобы лексер выделял токены, соответствующие этому регэкспу, только в случае заданного окружения.<br />
Один из кейсов: контексты необходимы, чтобы ключевые слова языка не парсились как подстроки строк (либо других ключевых слов), а также для реализации строк и символов (у них левый и правый контексты - кавычки).

Пустые символы (пробелы, табуляция, переводы строк) и комментарии (комментарии используют `#`) игнорируются.

**Результат работы лексера - набор токенов.**

## Реализация парсера

### Парсер-комбинаторы

Самый верхний слой в архитектуре парсера - парсер-комбинаторы.

Они сочетают парсеры определенным образом (например, конкатенация парсеров; применение ф-ии над результатом парсера; применение парсера до тех пор, пока он не выйдет из строя и т. п.).

За счет возможности перегрузки операторов в Python некоторые из них записаны были как операторы, благодаря чему появилась возможность удобно и в красивом виде записывать грамматику прямо в языке (например: `parser1 + parser2`, `parser1 ^ func`, `parser1 | parser2` и т. п.).

Парсер-комбинаторы - основа для написания грамматики.

Парсер-комбинаторы находся в файле `Parser/combinators.py`.

1. **Result** - класс, описывающий результат работы парсера (значение + позиция в массиве токенов).
2. **Combinator** - базовый класс для всех комбинаторов, в нём описана перегрузка операторов на применение определенных комбинаторов.
3. **Reserved** - позволяет парсить токены с заданным значением и тегом (например, комбинатор позволит распарсить токен с тегом `RESERVED` и значением `if` - результат будет соответствовать ключевому слову языка `if`).
4. **Tag** - позволяет парсить токены с заданным тегом (например, комбинатор позволит распарсить идентификатор (например, имя переменной), если передать ему тэг `ID`).
5. **Concat** - возвращает сконкатенированные результы работы двух парсерос. Если хотя бы один результат не успешен, комбинатор возвращает `None`.<br />Комбинатор использует перегруженный оператор `+`
6. **Alternate** - возвращает результат работы первого парсера, если он успешен, либо, если не успешен, результат второго.<br />Комбинатор использует перегруженный оператор `|`
7. **Opt** - возвращает результат работы парсера, если он успешен, либо, если не успешен, результат с пустым значением.
8. **Rep** - пытыается применить парсер до тех пор, пока он не выйден из строя; возвращает результат последней успешной попытки.
9. **Process** - применяет к результату работы парсера callback-функцию.<br />Комбинатор использует перегруженный оператор `^`
10. **Lazy** - применяет парсер лишь по месту использования (позволяет избежать случаев возникновения рекурсии при немедленном вызове парсеров).
11. **Phrase** - применяет парсер и возвращает результат только если были поглащены все токены. Этот комбинатор используется как самый верхнеуровневый - он используется в связке с парсером `stmt_list`, что позволяет избежать оставшихся нераспарсенных кусков кода в конце программы (парсить до самого конца).
12. **Exp** - используется для парсинга списков (принимает на вход два парсера: для элементов списка и для разделителей).<br />Комбинатор использует перегруженный оператор `*`

### Парсеры

Парсер представляет из себя класс, в котором с помощью комбинаторов и других парсеров оаписана грамматика той части языка, за которую ответственен этот парсер.

После успешного парсинга набора токенов по описанной грамматике парсер обычно передаёт управление описанной в нём же callback-функции (с помощью комбинатора `Process`), которая разыменовывает распарсенные токены и на основе них создаёт соответствующий AST-класс.

Таким образом, начиная с самого верхневровневого парсера - `stmt_list`, осуществляется рекурсивный проход "вгубь" программы путем попытки применения других парсеров вплоть до самых маленьких синтаксических контрукций языка: переменных, операторов и литералов.

После такого прохода все парсеры друг за другом возвращают соответствующие AST-классы - конструируется абстрактное синтаксическое дерево, и набор токенов превращает в AST.

#### Предопределенные функции

В нашем языке строки и массивы предлагают преопределенные функции (также, к ним относятся и input/output функции).

В файлах соответствующих парсеров (`arrays`, `strings`, `io`) составлены мапы, отображающие название функции на соответствующий ей AST-класс.
Данные мапы используется в парсере `fun_call_stmt`, который первым делом проверяет функцию на относящуюся к предопределенным, и если она к ним относится, то берет соответствующий AST-класс (вместо стандартного - `FunctionCallStatement`).

#### Расположение

Парсеры находся в директории `Parser/Parsers`.
1. `basic.py` - парсинг простых и общих выражений: таких как перечисления, числовые литералы, boolean.
2. `arithmetic_exprs.py` - парсинг арифметических выражений в соответствии с порядком группировки и уровнями старшества.
3. `boolean_exprs.py` - парсинг логических выражений в соответствии с порядком группировки и уровнями старшества.
4. `statements.py` - парсинг утверждений: присвоений, циклов, условий.
5. `io.py` - парсинг выражений, соответствующих операциям ввода-вывода.
6. `functions.py` - парсинг конструкций, связанных с реализацией функций.
7. `strings.py` - парсинг строк и символов, а также определение предопределенных функций для работы со строками и символами.
8. `arrays.py` - парсинг конструкций, связанных с реализацией массивов, а также определение предопределенных функций.

AST-классы находся в директории `Parser/AST`.

Файловая структура AST-классов почти в точности повторяет файловую структуру парсеров.

В `common.py` находятся AST-классы `Pointer` (реализация указателей) и `Enumeration` (перечисления: используются для описания массивов и аргументов функций)

**Результат работы парсера - AST.**

## Реализация интерпретатора

Вся реализация интерпретатора располагается непосредственно в AST-классах - в их методах `eval`.

Таким образом, чтобы исполнить AST, нам достаточно пройтись вглубь AST и с самой глубины начать вызывать методы `eval` AST-классов. После того, как мы исполним корневой AST-класс, будет выполнена вся программа.

Методы `eval` на вход принимают environment, в рамках которого они должны исполнить положенный им кусок AST.

### Environments

Основна интерпретатора - окружения (environments). В окружениях хранятся значения переменных, функции, вложенные окружения. Интерпретатор в зависимости от конкретного AST-класса разным образом взаимодействует с окружениями: кладёт туда что-то и извлекает.

Каждое окружение (кроме корневого) содержит ссылку на родительское окружение, и, если интерпретатор не находит переменную в текущем окружении, он осуществляет разворачивание стека, пробуя искать в вышестоящих окружениях, до тех пор, пока не найдет заданную переменную (либо не дойдет до корневого окружения).

Такая архитектура позволяет иметь локальные и глобальные переменные, взаимодействовать внутри блока как с локальными, так и с глобальными переменными.

Environment реализован в виде специального класса (располагающегося в `Parser/helpers.py`), который предоставляет методы создания окружения, получения значения из окружения и записи значения. При том сюда уже заложен механизм разворачивания стека по необходимости.

### Указатели

Поскольку язык предполагает наличие boxed-массивов (массивов ссылок) потребовалась реализация указателей.

При попытке записи переменных и других массивов в boxed-массивы осуществляется "заворачивание" присваемого значения в специальный класс `Pointer` (находится в `Parser/AST/common.py`), который принимает ссылку на environment, в котором находится значение, и выражение, соответствующее этому значению (простой или составной AST-класс).

Таким образом, при дальнешем обращении к элементам boxed-массива, будет получено актуально значение (возможно, изменившееся после присвоения) - будет вызван `eval` метод выражения в заданном окружении.

**Результат работы интерпретатора - результат выполнения переданной в виде AST программы.**

### Запуск

Запуск интерпретатора осуществляется следующим образом:

```
./rc -i program.expr
```
Где `program.expr` - путь к файлу с программой, которую нужно интерпретировать.

Например:
```
./rc -i compiler-tests/core/test025.expr
```

### Запуск тестов

Запуск тестов может быть осуществлен "из коробки", все пути уже замаплены нужным образом.

Для запуска набора тестов необходимо выполнить:
```
make -f checkInterpreter
```
Где `checkInterpreter` - make-файл, с командами запуска тестов и сверки результатов.

Например:
```
cd compiler-tests/core && make -f checkInterpreter
```
