## Актуальность

**На данный момент README требует дополнения с описанием:**
1. Реализации интерпретатора;
2. Реализации компилятора в код стековой машины;
3. Реализации стеквой виртуальной машины;
4. Реализации компилятора в ASM-код (NASM) под X86 и процесса сборки мусора.

Через некоторое время README будет обновлен.

# Учебный компилятор

## Features

1. **Арифметически выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
    1. `*`, `/`, `%`
    2. `+`, `-`
2. **Логические выражения** любой вложенности
с выполнением в соответствии с уровнями старшенства
и операторы сравнения и проверки равенства
    1. `==`, `!=`, `>`, `>=`, `<`, `<=`
    2. `&&`
    3. `||`, `!!`
3. **Переменые** 
    1. `x := 5 * y`
    2. `z := x <= y`
4. **Операции ввода-вывода** (ввод и вывод осуществляется в стандартные потоки ввода и вывода: stdin, stdout)
    1. `x := read()`
    2. `write(x)`
5. **Условия** с альтернативным ветками (как конкретными, так и обобщенными)
    ```
    if x >= y && z then
        write(x)
    elif !z then
        write(y)
    else
        write(z) fi   
    ```
6. **Циклы while**
    ```
    while k > 0
    do
        res := res * n;
        k := k - 1
    od;
    ```
7. **Циклы for** с поддержкой составных условий и skip в предусловии
    ```
    for c := 2, c * c <= p && f, c := c + 1
    do
        f := p % c != 0
    od;
    ```
    ```
    for skip, n >= 1, n := n-1
    do
        f := f * n
    od;
    ```
8. **Фукнции**
    ```
    fun A (m, n)
    begin
        if m == 0 then return n+1
        elif m > 0 && n == 0 then return A (m-1, 1)
        else return A (m-1, A(m, n-1))
        fi
    end
    
    write (A (1, 21))
    ```
    
9. **Символы**
    1. `C := 'a'`

10. **Строки** и набор предопределенных функций для работы с ними:<br />
    `S := "I will remember April."`
    1. **strlen** - получение длины строки:<br />
        `strlen(S)` => `22`
    2. **strget** - получение заданного символа строки:<br />
        `strget(S, 2)` => `w`
    3. **strsub** - получение подстроки, начиная с символа n, длиной в k символов:<br />
        `strsub (S, 7, 8)` => `remember`
    4. **strdup** - копирование строки:<br />
        `strdup(S)` => `I will remember April.`,
    5. **strset** - задание i-го символа строки:<br />
        `strset(S, 4, 'j')` => `I wijl remember April.`,
    6. **strcat** - конкатенация двух строк:<br />
        `strcat(S, " It was very cold.")` => `I will remember April. It was very cold.`,
    7. **strcmp** - сравнение двух строк (сравнение осуществляется по кодам символов строк, слева направо):<br />
        `strcmp(S, "I wijl remember April.")` => `1`<br />
        `strcmp(S, "I wiz")` => `-1`<br />
        `strcmp(S, "I will")` => `-1`<br />
        `strcmp(S, "I will remember April.")` => `0`
    8. **strmake** - создание строки из n повторящихся символов:<br />
        `strmake (10, 'a')` => `aaaaaaaaaa`

11. **Массивы значений** (unboxed-массивы) и набор предопределенных функций для работы с ними:<br />
    1. **arrmake** - создание массива:<br />
        1. `S := arrmake (5)` => `[0, 0, 0, 0, 0]`
        2. `S := arrmake (5, 0)` => `[0, 0, 0, 0, 0]`
        3. `S := arrmake (5, [])` => `[0, 0, 0, 0, 0]`
        4. `S := arrmake (5, [1, 2, 3, 4, 5])` => `[1, 2, 3, 4, 5]`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    4. Присвоение значения элементу массива по индексу:<br />
        `S[1] := 4` => `[0, 4, 0, 0, 0]`
    5. Получение значения элемента массива по индексу:<br /> 
        `write(S[1])` => `4`

11. **Массивы ссылок** (boxed-массивы), набор предопределенных функций для работы с ними, а также сборщик мусора (GC):<br />
    1. **Arrmake** - создание массива:<br />
        1. `S := Arrmake (5)` => `[nullptr, nullptr, nullptr, nullptr, nullptr]`
        2. `S := Arrmake (5, {})` => `[nullptr, nullptr, nullptr, nullptr, nullptr]`
        3. Присвоение со значением по умолчанию:<br />
            1. `S1 := arrmake (2, 1)` => `[1, 1]`
            2. `S2 := arrmake (2, 3)` => `[3, 3]`
            3. `S := Arrmake (2, {S1, S2})` => `[S1, S2]`
            4. `S2[1] := 4`
            5. `write(S[0][1])` => `1`
            6. `write(S[1][0])` => `3`
            7. `write(S[1][1])` => `4`
    2. **arrlen** - получение длины массивы:<br />
        `arrlen(S)` => `5`
    4. Присвоение ссылки элементу массива по индексу:<br />
        `S[1] := S1` => `[1, 1]`
    5. Получение значения элемента массива по индексу:<br /> 
        `write(S[1][0])` => `1`

#### Предопределенные функции

В данном языке строки и массивы предлагают преопределенные функции (также, к ним относятся и input/output функции).

В файлах соответствующих парсеров (`arrays`, `strings`, `io`) составлены мапы, отображающие название функции на соответствующий ей AST-класс.
Данные мапы используется в парсере `fun_call_stmt`, который первым делом проверяет функцию на относящуюся к предопределенным, и если она к ним относится, то берет соответствующий AST-класс (вместо стандартного - `FunctionCallStatement`).

#### Расположение

Парсеры находся в директории `Parser/Parsers`.
1. `basic.py` - парсинг простых и общих выражений: таких как перечисления, числовые литералы, boolean.
2. `arithmetic_exprs.py` - парсинг арифметических выражений в соответствии с порядком группировки и уровнями старшества.
3. `boolean_exprs.py` - парсинг логических выражений в соответствии с порядком группировки и уровнями старшества.
4. `statements.py` - парсинг утверждений: присвоений, циклов, условий.
5. `io.py` - парсинг выражений, соответствующих операциям ввода-вывода.
6. `functions.py` - парсинг конструкций, связанных с реализацией функций.
7. `strings.py` - парсинг строк и символов, а также определение предопределенных функций для работы со строками и символами.
8. `arrays.py` - парсинг конструкций, связанных с реализацией массивов, а также определение предопределенных функций.

AST-классы находся в директории `Parser/AST`.

Файловая структура AST-классов почти в точности повторяет файловую структуру парсеров.

В `common.py` находятся AST-классы `Pointer` (реализация указателей для интерпреатора) и `Enumeration` (перечисления: используются для описания массивов и аргументов функций)

**Результат работы парсера - AST.**

### Запуск

Запуск интерпретатора осуществляется следующим образом:

```
./rc -i program.expr
```
Где `program.expr` - путь к файлу с программой, которую нужно интерпретировать.

Например:
```
./rc -i compiler-tests/core/test025.expr
```

Запуск компилятора в код стековой виртуальной машины:

```
./rc -s program.expr
```
Где `program.expr` - путь к файлу с программой, которую нужно компилировать.

Например:
```
./rc -s compiler-tests/core/test025.expr
```

Запуск компилятора в ASM-код под X86:

```
./rc -o program.expr
```
Где `program.expr` - путь к файлу с программой, которую нужно компилировать.

Например:
```
./rc -o compiler-tests/core/test025.expr
```

### Запуск тестов

Запуск тестов может быть осуществлен "из коробки", все пути уже замаплены нужным образом.

Для запуска набора тестов необходимо выполнить:
```
make -f checkInterpreter
```
Где `checkInterpreter` - make-файл, с командами запуска тестов и сверки результатов.

Например:
```
cd compiler-tests/core && make -f checkInterpreter
```
```
cd compiler-tests/core && make -f checkStackMachine
```
```
cd compiler-tests/core && make -f checkCompiler
```
